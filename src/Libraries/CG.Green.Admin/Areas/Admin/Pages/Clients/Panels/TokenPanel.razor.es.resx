<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbsoluteRefreshTokenLifetime" xml:space="preserve">
    <value>Vida útil del Token de Actualización Absoluta</value>
  </data>
  <data name="AbsoluteRefreshTokenLifetimeHelp" xml:space="preserve">
    <value>Duración absoluta de un token de actualización en segundos.</value>
  </data>
  <data name="AccessTokenLifetime" xml:space="preserve">
    <value>Vida útil del Token de Acceso</value>
  </data>
  <data name="AccessTokenLifetimeHelp" xml:space="preserve">
    <value>Vida útil de un token de acceso en segundos.</value>
  </data>
  <data name="AccessTokens" xml:space="preserve">
    <value>Fichas de Acceso</value>
  </data>
  <data name="AccessTokenType" xml:space="preserve">
    <value>Tipo de Token de Acceso</value>
  </data>
  <data name="AccessTokenTypeHelp" xml:space="preserve">
    <value>Especifica si el token de acceso es un token de referencia o un token JWT autónomo.</value>
  </data>
  <data name="AllowAccessTokensViaBrowser" xml:space="preserve">
    <value>Permitir tokens de acceso a través del navegador</value>
  </data>
  <data name="AllowAccessTokensViaBrowserHelp" xml:space="preserve">
    <value>Controla si los tokens de acceso se transmiten a través del navegador para este cliente.</value>
  </data>
  <data name="AllowedSigningAlgorithms" xml:space="preserve">
    <value>Algoritmos de firma permitidos</value>
  </data>
  <data name="AllowedSigningAlgorithmsHelp" xml:space="preserve">
    <value>Algoritmo de firma para token de identidad. Si está vacío, utilizará el algoritmo de firma predeterminado de Duende</value>
  </data>
  <data name="AllowOfflineAccess" xml:space="preserve">
    <value>Permitir Acceso sin Conexión</value>
  </data>
  <data name="AllowOfflineAccessHelp" xml:space="preserve">
    <value>Habilitar/deshabilitar Tokens de Actualización.</value>
  </data>
  <data name="AlwaysIncludeUserClaimsInIdentityToken" xml:space="preserve">
    <value>Incluya siempre los reclamos de los usuarios en el token de identidad</value>
  </data>
  <data name="AlwaysIncludeUserClaimsInIdentityTokenHelp" xml:space="preserve">
    <value>Al solicitar un token de identificación y un token de acceso, las reclamaciones del usuario siempre deben agregarse al token de identificación en lugar de requerir que el cliente use el punto final de información de usuario.</value>
  </data>
  <data name="Broke" xml:space="preserve">
    <value>¡Algo se rompió!</value>
  </data>
  <data name="CoordinateLifetimeWithUserSession" xml:space="preserve">
    <value>Coordinar la vida útil con la sesión del usuario</value>
  </data>
  <data name="CoordinateLifetimeWithUserSessionHelp" xml:space="preserve">
    <value>Ate la vida útil del token del cliente a la vida útil de la sesión del usuario.</value>
  </data>
  <data name="Create" xml:space="preserve">
    <value>Crear</value>
  </data>
  <data name="CreateSigningAlgorithm" xml:space="preserve">
    <value>Crear Algoritmo de Firma</value>
  </data>
  <data name="EditSigningAlgorithm" xml:space="preserve">
    <value>Editar Algoritmo de Firma</value>
  </data>
  <data name="IdentityTokenLifetime" xml:space="preserve">
    <value>Vida útil del token de identidad</value>
  </data>
  <data name="IdentityTokenLifetimeHelp" xml:space="preserve">
    <value>Vida útil de un token de identidad en segundos.</value>
  </data>
  <data name="IdentityTokens" xml:space="preserve">
    <value>Fichas de Identidad</value>
  </data>
  <data name="LoadingSigningAlgorithms" xml:space="preserve">
    <value>Cargando algoritmos de firma...</value>
  </data>
  <data name="NoSigningAlgorithms" xml:space="preserve">
    <value>No se encontraron algoritmos de firma.</value>
  </data>
  <data name="RefreshTokenExpiration" xml:space="preserve">
    <value>Caducidad del Token de Actualización</value>
  </data>
  <data name="RefreshTokenExpirationHelp" xml:space="preserve">
    <value>Absoluto: el token de actualización caducará en un punto fijo en el tiempo. Deslizante: al actualizar el token, se renovará la vida útil del token de actualización.</value>
  </data>
  <data name="RefreshTokens" xml:space="preserve">
    <value>Fichas de actualización</value>
  </data>
  <data name="RefreshTokenUsage" xml:space="preserve">
    <value>Actualizar Uso de Token</value>
  </data>
  <data name="RefreshTokenUsageHelp" xml:space="preserve">
    <value>Reutilizar: el identificador del token de actualización permanecerá igual cuando se actualicen los tokens. OneTime: el identificador del token de actualización se actualizará al actualizar los tokens.</value>
  </data>
  <data name="RowsPerPage" xml:space="preserve">
    <value>Filas por página:</value>
  </data>
  <data name="SlidingRefreshTokenLifetime" xml:space="preserve">
    <value>Duración del Token de Actualización Deslizante</value>
  </data>
  <data name="SlidingRefreshTokenLifetimeHelp" xml:space="preserve">
    <value>Desplazamiento de la vida útil de un token de actualización en segundos.</value>
  </data>
  <data name="UpdateAccessTokenClaimsOnRefresh" xml:space="preserve">
    <value>Actualizar reclamos de token de acceso al actualizar</value>
  </data>
  <data name="UpdateAccessTokenClaimsOnRefreshHelp" xml:space="preserve">
    <value>Controla si el token de acceso (y sus reclamos) deben actualizarse en una solicitud de token de actualización</value>
  </data>
</root>